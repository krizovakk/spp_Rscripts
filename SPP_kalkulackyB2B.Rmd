---
title: "SPP :: Kalkulacky pro B2B segment"
author: "Katerina Krizova"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: false
    fig_caption: true
  fontsize: 11pt
  geometry: margin=1in
---

NG = natural gas
EE = electricity

# SETUP

```{r}
# ------------------------------------- packages

library(tidyverse)
library(readxl)
library(lubridate)
library(zoo)

# ------------------------------------- paths

path <- "C:/Users/krizova/Documents/R/cenove_kalkukacky/"

```

# LOAD DIAGRAM -- EE

diagram musi mit dva sloupce:
  1. date ve formatu POSIXct
  2. mwh ve formatu num

```{r}

load <- read_excel(paste0(path, "Bohemia Sekt_profil 2024_EE - kopie.xlsx"), col_names = T)         # diagram za 2024
# load <- read_excel(paste0(path, "erbaLachema.xls"), col_names = T)                                  # diagram za 09/24-08-25


diagram <-load %>% 
  mutate(
         year = lubridate::year(date),
         month = lubridate::month(date),
         week = lubridate::week(date),
         day = lubridate::day(date),
         weekday = lubridate::wday(date, week_start = 1),
         # pair = paste0(str_pad(week, 2, pad = "0"), "_", str_pad(weekday, 2, pad = "0"))
         md = paste0(month, "-", day),
         hol = case_when(
                        md == ("1-1") ~ "novy_rok",
                         md == ("5-1") ~ "svatek_prace",
                         md == ("5-8") ~ "konec_valky",
                         md == ("7-5") ~ "cyril_metod",
                         md == ("7-6") ~ "jan_hus",
                         md == ("9-28") ~ "sv_vaclav",
                         md == ("10-28") ~ "vznik_statu",
                         md == ("11-17") ~ "den_student",
                         md == ("12-24") ~ "stedry_den",
                         md == ("12-25") ~ "bozi_hod",
                         md == ("12-26") ~ "sv_stepan",
                         as.Date(date) %in% as.Date(c("2024-03-29", "2025-04-18")) ~ "easter_friday",
                         as.Date(date) %in% as.Date(c("2024-03-30", "2025-04-19")) ~ "easter_saturday",
                         as.Date(date) %in% as.Date(c("2024-03-31", "2025-04-20")) ~ "easter_sunday",
                         as.Date(date) %in% as.Date(c("2024-04-01", "2025-04-21")) ~ "easter_monday", # -------------------------------------------------------- pridat i ostatni roky ?
                        TRUE ~ "reg")
         ) %>%
  group_by(date) %>% mutate(hour = seq_along(date)) %>% ungroup() %>% 
  group_by(hour) %>% 
  mutate(mwh_reg = case_when(hol != "reg" & weekday %in% c(6:7) ~ mwh,
                             hol == "reg" ~ mwh, TRUE ~ NA),
         mwh_pair = ifelse(hol == "reg", mwh, 
                           zoo::na.locf(mwh_reg, na.rm = FALSE, fromLast = FALSE))) %>% # vyplní nejbližší dostupnou hodnotu v té samé hodině LAE ZATIM NE REG !!
  ungroup() %>% 
  select(hol, date, year, month, week, weekday, hour, mwh, mwh_reg, mwh_pair) %>% 
  filter(hour == 12)
  
 view(diagram)
  
  
  # group_by(hour) %>% mutate(mwh_reg = case_when(hol != "reg" & weekday %in% c(6:7) ~ mwh,
  #                            hol == "reg" ~ mwh, TRUE ~ NA),
  #        mwh_pair = ifelse(hol == "reg", mwh, 
  #                          zoo::na.locf(mwh_reg, na.rm = FALSE, fromLast = TRUE))) %>% # vyplní nejbližší dostupnou hodnotu z reg dne v té samé hodině
  # ungroup() 
  # # select(year, month, week, weekday, day, hour, hol, date, mwh, mwh_reg, mwh_pair) 
  # # filter(hour == 12) # -------------------------------------------------------------------------------------------------- jen operativne pro prehled - pak smazat



# check vvv

# now <- diagram %>% filter(date == as.Date("2024-03-31")) # DST - 23h
# fu <- future %>% filter(date == as.Date("2025-03-30")) # DST - 23h OK
# 
# now <- diagram %>% filter(date == as.Date("2024-10-27")) # DST - 25h
# fu <- future %>% filter(date == as.Date("2025-10-26")) # DST - 25h OK

# tr <- diagram %>% filter(date == as.Date("2024-03-29"))
  
```

# SET TIME RANGE

```{r}
val_y1 <- unique(max(diagram$year))+1 # v pripade, ze nebude diagram za jeden kalendarni rok, ale treba prelom (proto max)
val_y2 <- unique(max(diagram$year))+2
val_y3 <- unique(max(diagram$year))+3
```

# CREATE FUTURE DIAGRAM

```{r}

future <- tibble(
  timestamp = seq(
    from = as.POSIXct(paste0(val_y1, "-01-01 00:00:00"), tz = "Europe/Prague"),
    to   = as.POSIXct(paste0(val_y3, "-12-31 23:00:00"), tz = "Europe/Prague"),
    by   = "hour")) %>% 
  mutate(
    date = as_date(timestamp),
    weekday = wday(timestamp, week_start = 1),  # Monday = 1
    year = lubridate::year(timestamp),
    month = lubridate::month(timestamp),
    week = lubridate::week(timestamp),
    day = lubridate::day(timestamp),
    md = paste0(month, "-", day),
    hol = case_when(md %in% c("1-1", 
                                   "5-1", "5-8", "7-5", "7-6", 
                                   "9-8", "10-28", "11-17",
                                   "12-24", "12-25", "12-26") ~ "ph", # public holiday
                        date %in% c("2025-04-18", "2026-04-03", "2027-03-26") ~ "easter_friday",
                        date %in% c("2025-04-19", "2026-04-04", "2027-03-27") ~ "easter_saturday",
                        date %in% c("2025-04-20", "2026-04-05", "2027-03-28") ~ "easter_sunday",
                        date %in% c("2025-04-21", "2026-04-06", "2027-03-29") ~ "easter_monday",
                        TRUE ~ "reg")) %>% 
  group_by(date) %>% mutate(hour = seq_along(date)) %>% 
  ungroup() %>% 
  select(year, month, week, weekday, hour, hol, date) 
  # filter(hour == 12) # -------------------------------------------------------------------------------------------------- jen operativne pro prehled - pak smazat
  
view(future)

```

# JOIN

-- wip, funguje, jen treba vymyslet NA a posun tydnu do 2027 a if(2024 == ph, vem nejbližší reg...)

  mwh = puvodni hodnoty z diagramu
  mwh_wday = mwh prirazene na zaklade nejblizsiho dne v tydnu
  mwh_hol = mwh prirazene na zaklade presneho datumu, protoze public holiday
  mwh_futu = vysledek podminky: vyber prirazeni na zaklade promenne hol 
  
*!! nutne osetrit NA !!*

```{r}

join <- future %>% 
  full_join(diagram %>% select(week, weekday, day, hour, mwh_pair), by = c("week", "weekday", "hour")) %>% 
  rename("mwh" = mwh_pair) %>% filter(hour == 12)

view(join)



  mutate(day = lubridate::day(date)) %>% # potrebujeme zachovat datum z future a ne z diagram
  full_join(diagram %>% select(month, day, hour, hol, mwh_pair), by = c("month", "day", "hour", "hol")) %>% 
  mutate(mwh_hol = ifelse(hol == "ph", mwh, NA),
         mwh_futu = ifelse(hol == "ph", mwh_hol, mwh_wday)) %>% 
  select(hol, date, year, month, day, hour, week, weekday, mwh_futu) %>% 
  filter(!is.na(date)) %>% filter(hour == 12)

view(join)

# exp, asi blbost 

join_fl <- join %>% 
  group_by(week, weekday, hour) %>%
  ungroup() 
  mutate(mwh = ifelse(is.na(mwh_futu), mwh_52, mwh_futu)) %>%
  filter(hour == 12)

join$mwh_futu <- ifelse(is.na(join$mwh_futu), mean(join$mwh_futu[join$weekday]))

```

# VELIKONOCE

pro vsechny vyskyty jednotlivych velikonocnich dni prepise hodnoty z diagramu

```{r}

# levely, pro které chcete přepsat mwh
to_replace <- c("easter_friday", "easter_saturday", "easter_sunday", "easter_monday")

# funkce
for (lev in to_replace) {
  join$mwh[join$hol == lev] <- diagram$mwh_pair[diagram$hol == lev]
}

rm(lev)
rm(to_replace)

```

# --------- experimental section below

```{r}

diagram <- load %>% 
  mutate(
         year = lubridate::year(date),
         month = lubridate::month(date),
         week = lubridate::week(date),
         day = lubridate::day(date),
         weekday = lubridate::wday(date, week_start = 1),
         # pair = paste0(str_pad(week, 2, pad = "0"), "_", str_pad(weekday, 2, pad = "0"))
         md = paste0(month, "-", day),
         hol = case_when(
                        md == ("1-1") ~ "novy_rok",
                         md == ("5-1") ~ "svatek_prace",
                         md == ("5-8") ~ "konec_valky",
                         md == ("7-5") ~ "cyril_metod",
                         md == ("7-6") ~ "jan_hus",
                         md == ("9-28") ~ "sv_vaclav",
                         md == ("10-28") ~ "vznik_statu",
                         md == ("11-17") ~ "den_student",
                         md == ("12-24") ~ "stedry_den",
                         md == ("12-25") ~ "bozi_hod",
                         md == ("12-26") ~ "sv_stepan",
                         as.Date(date) %in% as.Date(c("2024-03-29", "2025-04-18")) ~ "easter_friday",
                         as.Date(date) %in% as.Date(c("2024-03-30", "2025-04-19")) ~ "easter_saturday",
                         as.Date(date) %in% as.Date(c("2024-03-31", "2025-04-20")) ~ "easter_sunday",
                         as.Date(date) %in% as.Date(c("2024-04-01", "2025-04-21")) ~ "easter_monday", # -------------------------------------------------------- pridat i ostatni roky ?
                        TRUE ~ "reg"),
         mwh_pair = case_when(hol != "reg" & weekday %in% c(6:7) ~ mwh,
                             hol == "reg" ~ mwh, TRUE ~ NA)
         ) %>%
  group_by(date) %>% mutate(hour = seq_along(date)) %>% ungroup() %>%
  select(hol, date, year, month, week, weekday, hour, mwh, mwh_pair) %>% 
  filter(hour == 12)
  
view(diagram)

# nize funkcni chatGPT sekce, ktera vyplni nejblizsi reg hodnotu - overeno

fill_nearest_reg <- function(df) {
  reg_idx <- which(diagram$hol == "reg" & !is.na(diagram$mwh_pair))  # Get indices where hol == "reg" and mwh_pair is not NA
    nearest_reg_value <- sapply(seq_len(nrow(diagram)), function(i) { # For each row, find nearest index among reg rows
    if (!is.na(diagram$mwh_pair[i])) return(diagram$mwh_pair[i])
    if (length(reg_idx) == 0) return(NA)
    nearest <- reg_idx[which.min(abs(reg_idx - i))]   # find the index of reg row closest to i
    return(diagram$mwh_pair[nearest])
  })
  diagram$mwh_pair_filled <- nearest_reg_value
  diagram
}

df_filled <- fill_nearest_reg(diagram)
df_filled

```
